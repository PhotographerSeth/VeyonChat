#include "MasterChatDialog.h"
#include "ui_MasterChatDialog.h" // This will be generated by Qt's UIC
#include <QShortcut>
#include <QKeyEvent>
#include <QDateTime>
#include <QDebug>

// A minimal UI can be defined directly here if you don't use a .ui file
// For a real project, you would create a MasterChatDialog.ui file in Qt Designer
namespace Ui {
    class MasterChatDialog {
    public:
        // Pointers to UI elements
        QListWidget* clientListWidget;
        QTextEdit* chatHistoryTextEdit;
        QLineEdit* messageLineEdit;
        QPushButton* sendButton;
        QPushButton* clearHistoryButton;
        QComboBox* priorityComboBox;
        QVBoxLayout* mainLayout;
        // ... and other UI elements

        void setupUi(QWidget *MasterChatDialog) {
             // This is a placeholder for actual UI setup.
             // In a real Qt project, this is handled automatically
             // by loading a .ui file.
            mainLayout = new QVBoxLayout(MasterChatDialog);
            clientListWidget = new QListWidget(MasterChatDialog);
            chatHistoryTextEdit = new QTextEdit(MasterChatDialog);
            chatHistoryTextEdit->setReadOnly(true);
            messageLineEdit = new QLineEdit(MasterChatDialog);
            messageLineEdit->setPlaceholderText("Type a message...");
            sendButton = new QPushButton("Send", MasterChatDialog);
            clearHistoryButton = new QPushButton("Clear History", MasterChatDialog);
            priorityComboBox = new QComboBox(MasterChatDialog);
            priorityComboBox->addItems({"Normal", "Urgent", "Announcement"});

            QHBoxLayout* bottomLayout = new QHBoxLayout();
            bottomLayout->addWidget(messageLineEdit);
            bottomLayout->addWidget(priorityComboBox);
            bottomLayout->addWidget(sendButton);

            mainLayout->addWidget(new QLabel("Clients:"));
            mainLayout->addWidget(clientListWidget);
            mainLayout->addWidget(new QLabel("Chat History:"));
            mainLayout->addWidget(chatHistoryTextEdit);
            mainLayout->addLayout(bottomLayout);
            mainLayout->addWidget(clearHistoryButton);

            MasterChatDialog->setLayout(mainLayout);
            MasterChatDialog->setWindowTitle("Veyon Master Chat");
        }
    };
}


MasterChatDialog::MasterChatDialog(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::MasterChatDialog)
{
    ui->setupUi(this);
    setupShortcuts();

    connect(ui->sendButton, &QPushButton::clicked, this, &MasterChatDialog::onSendButtonClicked);
    connect(ui->clearHistoryButton, &QPushButton::clicked, this, &MasterChatDialog::onClearHistoryClicked);
    connect(ui->messageLineEdit, &QLineEdit::returnPressed, this, &MasterChatDialog::onSendButtonClicked);

    // TODO: Connect signal for receiving messages from clients
}

MasterChatDialog::~MasterChatDialog()
{
    delete ui;
}

void MasterChatDialog::setupShortcuts()
{
    m_f10Shortcut = new QShortcut(QKeySequence(Qt::Key_F10), this);
    connect(m_f10Shortcut, &QShortcut::activated, this, &MasterChatDialog::toggleWindowVisibility);
}

void MasterChatDialog::toggleWindowVisibility()
{
    if (isVisible()) {
        // As requested, minimize instead of hide
        this->setWindowState(Qt::WindowMinimized);
    } else {
        this->setWindowState(Qt::WindowNoState); // Restore
        this->show();
    }
}


void MasterChatDialog::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_Escape) {
        this->setWindowState(Qt::WindowMinimized);
        event->accept();
    } else {
        QWidget::keyPressEvent(event);
    }
}

void MasterChatDialog::setSelectedClients(const QSet<QString>& clientIds)
{
    m_selectedClients = clientIds;
    updateClientList();
}

void MasterChatDialog::updateClientList()
{
    ui->clientListWidget->clear();
    for(const QString& id : qAsConst(m_selectedClients))
    {
        // In a real implementation, you'd look up the client's hostname
        ui->clientListWidget->addItem(id);
    }
    // Select the first client by default
    if(ui->clientListWidget->count() > 0)
    {
        ui->clientListWidget->setCurrentRow(0);
    }
}

void MasterChatDialog::onSendButtonClicked()
{
    QString message = ui->messageLineEdit->text().trimmed();
    if(message.isEmpty()) {
        return;
    }

    QString priority = ui->priorityComboBox->currentText();
    QString masterName = "Master"; // TODO: Make this configurable

    // Add message to local history
    QString timestamp = QDateTime::currentDateTime().toString("hh:mm:ss");
    QString formattedMessage = QString("[%1] %2 (You): %3").arg(timestamp, masterName, message);
    ui->chatHistoryTextEdit->append(formattedMessage);

    // Send message to all selected clients
    sendMessageToClients(message, priority);

    ui->messageLineEdit->clear();
}

void MasterChatDialog::onClearHistoryClicked()
{
    // TODO: Also send a command to the client to clear their history
    ui->chatHistoryTextEdit->clear();
}

void MasterChatDialog::sendMessageToClients(const QString& message, const QString& priority)
{
    // This is the core logic for sending data.
    // You will need to use Veyon's remote procedure call mechanism.
    qInfo() << "Sending message to" << m_selectedClients.count() << "clients...";

    for(const QString& clientId : qAsConst(m_selectedClients))
    {
        qInfo() << " -> to" << clientId << ":" << message << "(Priority:" << priority << ")";
        // PSEUDO-CODE for Veyon communication
        /*
        Veyon::Core::RemoteProcedureCall rpc("VeyonChat", "receiveMessage");
        rpc.addArgument("message", message);
        rpc.addArgument("priority", priority);
        rpc.addArgument("sender", "Master");
        Veyon::Master::MasterCore::instance()->clientManager()->executeRemoteProcedureCall(clientId, rpc);
        */
    }
}
